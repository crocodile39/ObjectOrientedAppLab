//Objects
var player;
var score = 0;
var scoreText;
var loseText;
var block;
var jetPack;
var zaps = [];
var missles = [];
var coin;

//Settings
var minimumTrapTime = 2500;
var maximumTrapTime = 6000;
var minimumTrapCount = 1;
var maximumTrapCount = 2;

//Called once before the first frame
function Start()
{

  var floor = Instantiate("floor", 0, 440, 320, 10, Color.black, true, true);
  floor.AddComponent(boxCollider);
  floor.staticPosition = true;
  floor.tag = "block";
  var roof = Instantiate("roof", 0, -1, 320, 10, Color.black, true, true);
  roof.AddComponent(boxCollider);
  roof.staticPosition = true;
  roof.tag = "block";

  player = Instantiate("player", 30, 100, 30, 30, Color.blue, true, true);
  CreateScript("PlayerScript");
  player.AddComponent(rigidBody);
  player.AddComponent(boxCollider);
  player.tag = "player";
  player.AddComponent(script, "PlayerScript");
  player.variables.speed = 2;
  player.variables.jetSpeed = 0.1;
  player.variables.dead = false;
  jetPack = Instantiate("jetPack", 30, 100, 10, 30, Color.grey, true, true);
  jetPack.variables.fire = Instantiate("jetPack", 30, 100, 10, 10, Color.red, true, true);


  scoreText = CreateText("score", "Score: " + score, -10, -15, Color.blue);
  loseText = CreateText("lose", "YOU LOSE", -10, 200, Color.red);
  setProperty(loseText, "font-size", 36);
  setProperty(loseText, "hidden", true);

  block = Instantiate("block", -160, 160, 20, randomNumber(45, 95), Color.orange, true, true);
  block.AddComponent(boxCollider);
  block.tag = "block";
  
  //Missles
  for(var h = 0; h < 3; h++)
  {
    var missle = Instantiate("block", -160, 160, 60, 40, Color.black, false, true);
    missle.AddComponent(boxCollider);
    missle.tag = "block";
    missle.variables.warning = CreateText(missle.name, "!", 285, missle.transform.position.y - 75, Color.red);
    setProperty(missle.variables.warning, "hidden", true);
    setProperty(missle.variables.warning, "font-size", 50);
    setProperty(missle.variables.warning, "x", 285 - (57 * h));
    appendItem(missles, missle);
  }
  
  
  //Zap Traps
  for(var i = 0; i < 4; i++)
  {
    var zap = Instantiate("zap", 0, 1320, 320, 10, Color.red, false, true);
    zap.AddComponent(boxCollider);
    zap.staticPosition = true;
    zap.tag = "block";
    zap.spriteRenderer.color = rgb(255, 0, 0, 0.1);
    appendItem(zaps, zap);
  }
  
  
  //Coin
  coin = Instantiate("coin", 320, 225, 20, 20, Color.yellow, true, false);
  coin.variables.text = CreateText("coinText", "$", -20, -2000, Color.black);
  setProperty(coin.variables.text, "font-size", 12);
  coin.transform.position.x = player.transform.position.x + randomNumber(450, 700);
  coin.transform.position.y = randomNumber(35,410);

  Respawn();
  NewTrap();
}
//Called every frame
function Update()
{  
  setProperty("screen1", "background-color", rgb(0, 150, 255, 0.3));
  if(player.transform.position.x > block.transform.position.x + 200)
  {
    block.transform.position.x = player.transform.position.x + randomNumber(450, 700);
    block.transform.position.y = randomNumber(0,450 - block.transform.scale.height);
  }
  if(player.transform.position.x > coin.transform.position.x + 200)
  {
    coin.transform.position.x = player.transform.position.x + randomNumber(450, 700);
    coin.transform.position.y = randomNumber(35,410);
  }
  setProperty(coin.variables.text, "x", coin.transform.position.x - 184);
  setProperty(coin.variables.text, "y", coin.transform.position.y - 99);

}


function NewTrap()
{
  var waitTime = randomNumber(minimumTrapTime, maximumTrapTime);
  var trapSpawn = timedLoop(waitTime, function()
  {
    var trapCount = randomNumber(minimumTrapCount, maximumTrapCount);
    var possibleTraps = [0, 1];
    for(var i = 0; i < trapCount; i++)
    {
      var trapIndex = randomNumber(0, possibleTraps.length - 1);
      var trapChoice = possibleTraps[trapIndex];
      removeItem(possibleTraps, trapIndex);
      switch(trapChoice)
      {
        case 0:
          ZapTrap();
          break;
        case 1:
          MissleTrap();
          break;
      }
    }
    var callNewTrap = timedLoop(6000, function()
    {
      NewTrap();
      stopTimedLoop(callNewTrap);
    });
    stopTimedLoop(trapSpawn);
  });
  
}

function MissleTrap()
{
  var count = randomNumber(1, missles.length);
  for(var i = 0; i < count; i++)
  {
    Missle(i);
  }
}
function Missle(i)
{
  var missle = missles[i];
  var blinkCount = 0;
  var totalBlinks = randomNumber(10, 30);
  var on = true;
  missle.transform.position.y = randomNumber(90, 360);
  setProperty(missle.variables.warning, "y", missle.transform.position.y - 75);
  var blinkWarning = timedLoop(130, function()
  {
    on = !on;
    setProperty(missle.variables.warning, "hidden", on);
    blinkCount++;
    if(blinkCount >= totalBlinks)
    {
      setProperty(missle.variables.warning, "hidden", true);
      missle.transform.position.x = 360;
      missle.transform.Move(-3, 0);
      stopTimedLoop(blinkWarning);
    }
  });
}
function ResetMissles()
{
  for(var i = 0; i < missles.length; i++)
  {
    missles[i].transform.position.x = -360;
  }
}

function ZapTrap()
{
  if(Math.random() < 0.5)
  {
    zaps[0].transform.position.y = 325;
    zaps[1].transform.position.y = 275;
    zaps[2].transform.position.y = 225;
    zaps[3].transform.position.y = 175;
  }
  else
  {
    zaps[0].transform.position.y = 375;
    zaps[1].transform.position.y = 325;
    zaps[2].transform.position.y = 75;
    zaps[3].transform.position.y = 125;
  }
  

  for(var i = 0; i < zaps.length; i++)
  {
    zaps[i].active = false;
  }
  var a = 0.01;
  var charge = timedLoop(10, function(){
      for(var i = 0; i < zaps.length; i++)
      {
        zaps[i].spriteRenderer.color = rgb(255, 0, 0, a);
      }
      a += 0.001;
      if(a > 0.25)
      {
         var finishZap = timedLoop(1000, function(){
              for(var i = 0; i < zaps.length; i++)
              {
                zaps[i].spriteRenderer.color = rgb(255, 0, 0, 1);
                zaps[i].active = true;
              }
              var endZap = timedLoop(3000, function(){
                  EndZap();
                  stopTimedLoop(endZap);
              });
              stopTimedLoop(finishZap);
          });
        stopTimedLoop(charge);
      }
  });
 
}
function EndZap()
{
  for(var i = 0; i < zaps.length; i++)
  {
    zaps[i].spriteRenderer.color = rgb(255, 0, 0, 0.1);
    zaps[i].active = false;
    zaps[i].transform.position.y = 1000;
  }
}


function PlayerScript()
{
  var rb = player.Rigidbody;
  UpdateJetPack(rb);
  
  if(player.BoxCollider.collisions.count > 0 && !player.variables.dead)
  {
    if(player.BoxCollider.collisions.CompareTag("block"))
    {
      Die();
    }
  }
  if(DistanceBetween(player, coin) < 30)
  {
      score += 10;
      coin.transform.position.x = player.transform.position.x + randomNumber(450, 700);
      coin.transform.position.y = randomNumber(0,410);
      SetScoreTextYellow();
      Wait(0.2, "SetScoreTextBlack");
      Wait(0.4, "SetScoreTextYellow");
      Wait(0.6, "SetScoreTextBlack");
      Wait(0.8, "SetScoreTextYellow");
      Wait(1, "SetScoreTextBlack");
  }
  
  camera.transform.position.x = player.transform.position.x + 50;
  score += 0.01;
  setProperty(scoreText, "text", Math.round(score));
}
function UpdateJetPack(rb)
{
  if(!player.variables.dead)
  {
    rb.SetVelocity(player.variables.speed, rb.velocity.y);
    if(verticalInput < 0)
    {
      rb.velocity.y -= player.variables.jetSpeed;
    }
    jetPack.transform.position.x = player.transform.position.x - 5;
    jetPack.transform.position.y = player.transform.position.y;
    jetPack.variables.fire.transform.position.x = jetPack.transform.position.x;
    jetPack.variables.fire.transform.position.y = jetPack.transform.position.y + 25;
    jetPack.variables.fire.transform.scale.height = Math.min(-(Math.pow(player.Rigidbody.velocity.y, 3)) - (verticalInput * 7), 15);
  }
}
function SetScoreTextYellow()
{
  setProperty(scoreText, "text-color", Color.yellow);
}
function SetScoreTextBlack()
{
  setProperty(scoreText, "text-color", Color.black);
}

function Die()
{
  player.Rigidbody.SetVelocity(0,0);
  player.Rigidbody.useGravity = false;
  player.variables.dead = true;
  SetColorRed();
  Wait(0.25, "SetColorBlue");
  Wait(0.5, "SetColorRed");
  Wait(0.75, "SetColorBlue");
  Wait(1, "SetColorRed");
  Wait(1.25, "SetColorBlack");
  Wait(1.75, "Respawn");
  setProperty(loseText, "hidden", false);
  SetBackground(Color.grey);
}
function SetColorRed()
{
  player.spriteRenderer.color = Color.red;
}
function SetColorBlue()
{
  player.spriteRenderer.color = Color.blue;
}
function SetColorBlack()
{
  player.spriteRenderer.color = Color.black;
}
function Respawn()
{
  score = 0;
  block.transform.position.x = player.transform.position.x + randomNumber(450, 700);
  block.transform.position.y = randomNumber(0,450 - block.transform.scale.height);
  coin.transform.position.x = player.transform.position.x + randomNumber(450, 700);
  coin.transform.position.y = randomNumber(35,410);
  EndZap();
  ResetMissles();
  
  player.transform.position.y = 225;
  player.transform.scale.height = 30;
  player.transform.scale.width = 30;
  player.Rigidbody.useGravity = true;
  player.spriteRenderer.color = Color.blue;
  Wait(0.1, "SetDeadTrue");
  setProperty(loseText, "hidden", true);
  SetBackground(Color.white);
}
function SetDeadTrue()
{
  player.variables.dead = false;
}


//Game Engine
{
  //Usable Variables
  {
    //Use Color.nameOfColor to use one of the colors
    var Color = {black : "black", white: "white", grey: "gray", gray: "gray", red: "red", orange: "orange", yellow: "yellow", green: "green", blue: "blue", indigo: "indigo", violet: "violet"};
    //Has a value of 1 when D is held down, a value of -1 when A is held down, and 0 if neither are held down
    var horizontalInput = 0;
    //Has a value of 1 when S is held down, a value of -1 when W is held down, and 0 if neither are held down
    var verticalInput = 0;
    //Holds values of held or not held down for each key
    var Input = {};
    //Use the Input.getKey("lowercase key name") to get returned if the key is pressed or not
    Input.getKey = function getKey(key)
    {
      switch(key)
      {
        case "q":
          return KeyStates.q;
        case "w":
          return KeyStates.w;
        case "e":
          return KeyStates.e;
        case "r":
          return KeyStates.r;
        case "t":
          return KeyStates.t;
        case "y":
          return KeyStates.y;
        case "u":
          return KeyStates.u;
        case "i":
          return KeyStates.i;
        case "o":
          return KeyStates.o;
        case "p":
          return KeyStates.p;
        case "a":
          return KeyStates.a;
        case "s":
          return KeyStates.s;
        case "d":
          return KeyStates.d;
        case "f":
          return KeyStates.f;
        case "g":
          return KeyStates.g;
        case "h":
          return KeyStates.h;
        case "j":
          return KeyStates.j;
        case "k":
          return KeyStates.k;
        case "l":
          return KeyStates.l;
        case "z":
          return KeyStates.z;
        case "x":
          return KeyStates.x;
        case "c":
          return KeyStates.c;
        case "v":
          return KeyStates.v;
        case "b":
          return KeyStates.b;
        case "n":
          return KeyStates.n;
        case "m":
          return KeyStates.m;
        case "up":
          return KeyStates.up;
        case "right":
          return KeyStates.right;
        case "down":
          return KeyStates.down;
        case "left":
          return KeyStates.left;
        
      }
    };
  }
  
  //Constant Updates
  {
    //Called every frame to control all the whole game
    function draw()
    {
      DetermineInputValues();
      Update();
      CheckScripts();
      if(updateColors)
      {
        UpdateColors();
      }
      ApplyCameraPosition();
      ApplyCollisions();
      ApplyGravity();
      ApplyVelocities();
      ApplyMoves();
      ApplyPositions();
    }
    
    //Called less often than draw() for function that aren't as important
    function slowDraw()
    {
      if(turnOffNonVisible)
      {
        TurnOffNonVisible();
      }
    }
  }
  
  //Gameobject Handling
  {
    //Holds all GameObjects in the game
    var GameObjects = [];
    
    //Holds all script names in the game
    var Scripts = [];
    
    //Used to pass into the AddComponent function
    var rigidBody = "rigidBody"; //Gives gravity to an object
    var boxCollider = "boxCollider"; //Allows object to collide with objects or be collided with
    var script = "script"; //Gives a function for an object to use
    
    //Holds all static GameObjects
    var StaticGameObjects = [];
    
    //Used to create objects. Requires name, x and y position, width and height, and color.
    function Instantiate(name, x, y, width, height, color, outline, square)
    {
      var ngo = {}; //Holds all GameObject info
      ngo.name = name; //Name of the object
      ngo.tag = "default"; //Can be used as an identifier 
      ngo.active = true; //Whether this objects collider and rigidbody are calculated
      ngo.staticPosition = false; //Whether this object stays with the camera
      ngo.transform = {}; //Holds position and scale info
      
      ngo.transform.position = {x: x, y: y}; //X and y position of object
      if(width > 320)
      {
        console.log("When instantiating, width cannot be greater than 320");
        width = 320;
      }
      if(height > 450)
      {
        console.log("When instantiating, heigh cannot be greater than 450");
        height = 450;
      }
      ngo.transform.scale = {width: width, height: height}; //Width and heigh of object
      ngo.transform.position.direction = {x: 0, y: 0}; //Direction for this object to move. Seperate from velocity
      //Sets direction for this object to move every update
      ngo.transform.Move = function Move(x,y)
      {
        ngo.transform.position.direction.x = x;
        ngo.transform.position.direction.y = y;
      };
      
    
      ngo.spriteRenderer = {color: color, outline: outline, square : square}; //Holds color of object
      appendItem(GameObjects, ngo);
      DrawObject(ngo);
      ngo.variables = {};
      
      //Sets the object to active or not, with a optional delay to the change
      ngo.SetActive =  function SetActive(on, time)
      {
        if(time == null)
        {
          ngo.active = on;
          if(ngo.active)
          {
            setPosition(ngo.name, ngo.transform.position.x, ngo.transform.position.y);
          }
          else
          {
            setPosition(ngo.name, 1000, 1000);
          }
          UpdateActiveColliders();
        }
        else
        {
          time *= 1000;
          var newLoop = timedLoop(time, function(){
              ngo.active = on;
              if(ngo.active)
              {
                setPosition(ngo.name, ngo.transform.position.x, ngo.transform.position.y);
              }
              else
              {
                setPosition(ngo.name, 1000, 1000);
              }
              UpdateActiveColliders();
              stopTimedLoop(newLoop);
          });
        }
      };
      
      //Allows for adding more components to object. For example: rigidbody, boxCollider, and script
      ngo.AddComponent = function AddComponent(component, info)
      {
        switch(component)
        {
          case rigidBody:
            if(ngo.Rigidbody != null)
            {
              console.log("You have already added a " + component + " to " + ngo.name + ". Do not add more than one");
            }
            else
            {
              ngo.Rigidbody = {};
              ngo.Rigidbody.velocity = {x: 0, y: 0};
              ngo.Rigidbody.useGravity = {gravity: true};
              ngo.Rigidbody.SetVelocity = function AddComponent(x, y)
              {
                if(x != null && y != null)
                {
                  ngo.Rigidbody.velocity.x = x;
                  ngo.Rigidbody.velocity.y = y;
                }
                else
                {
                  console.log("When using Rigidbody.SetVelocity(), you must input a x and y value");
                }
              };
              ngo.Rigidbody.AddForce = function AddForce(x, y)
              {
                    x /= 10;
                    y /= 10;
                    var currentVelocityX = x;
                    var currentVelocityY = -y;
                    var resistance = 0.01;
                    var newLoop = timedLoop(fixedTime, function(){
                    currentVelocityX -= resistance;
                    currentVelocityY += resistance;
                    if(currentVelocityX > 0)
                    {
                      ngo.Rigidbody.velocity.x += currentVelocityX;
                    }
                    if(currentVelocityY < 0)
                    {
                      ngo.Rigidbody.velocity.y += currentVelocityY;
                    }
                    if(currentVelocityX <= 0 && currentVelocityY >= 0)
                    {
                      stopTimedLoop(newLoop);
                    }
                });
              };
            }
            break;
          case boxCollider:
            if(ngo.BoxCollider != null)
            {
              console.log("You have already added a " + component + " to " + ngo.name + ". Do not add more than one");
            }
            else
            {
              ngo.BoxCollider = {x: ngo.transform.position.x, y: ngo.transform.position.y, width: ngo.transform.scale.width, height: ngo.transform.scale.height};
              ngo.BoxCollider.collisions = {up: false, right: false, down: false, left: false};
              ngo.BoxCollider.collisions.count = {};
              ngo.BoxCollider.collisions.info = [];
              ngo.BoxCollider.active = true;
              ngo.BoxCollider.collisions.CompareTag = function CompareTag(tag)
              {
                for(var curcol = 0; curcol < ngo.BoxCollider.collisions.info.length; curcol++)
                {
                  var hitObj = ngo.BoxCollider.collisions.info[curcol];
                  if(hitObj.tag == tag)
                  {
                    return true;
                  }
                }
              };
              ngo.BoxCollider.collisions.GetTag = function GetTag(tag)
              {
                for(var curcol = 0; curcol < ngo.BoxCollider.collisions.info.length; curcol++)
                {
                  var hitObj = ngo.BoxCollider.collisions.info[curcol];
                  if(hitObj.tag == tag)
                  {
                    return ngo.BoxCollider.collisions.info[curcol];
                  }
                }
              };
            }
            UpdateActiveColliders();
            break;
          case "script":
            for(var scr = 0; scr < Scripts.length; scr++)
            {
              if(Scripts[scr].name == info)
              {
                appendItem(Scripts[scr].objects, FindGameObjectIndex(ngo));
              }
            }
            break;
        }
      };
      return ngo;
    }
    
    //Creates a object that isn't added to GameObjects array, but also cannot have components, which can help with performance
    function InstantiateStatic(x, y, width, height, color)
    {
      var name = "staticObject" + randomNumber(0, 100000);
      appendItem(StaticGameObjects, name);
      createCanvas(name);
      setActiveCanvas(name);
      setPosition(name,x, y);
      setFillColor(color);
      rect(0, 0, width, height);
    }
    
    //Creates a map based on a string passed in with certain rules:
      //"_" = floor
      //" " = gap
      //">" = move next builds right
      //"<" = move next builds left
      //"r" = chooses random choice from above
      //"d" = repeates previous choices
    function InstantiateString(map, color)
    {
      var chars = map.split('');
      var x = 0;
      var y = 200;
      var width = 160;
      var height = 50;
      var col = (color == null ? Color.green : color);
      for(var i =0; i < chars.length; i++)
      {
        switch(chars[i])
        {
          case "_":
            var ifloor = Instantiate("floor", x, y, width, height, col);
            ifloor.AddComponent(boxCollider);
            ifloor.tag = "floor";
            x += width;
            break;
          case " ":
            x += (width / 2);
            break;
          case ">":
            x += (width / 2);
            break;
          case "<":
            x -= (width / 2);
            break;
          case "+":
            y -= height;
            break;
          case "-":
            y += height;
            break;
          case "d":
            for(var j = 0; j < i; j++)
            {
              switch(chars[j])
              {
                case "_":
                  var ifloor2 = Instantiate("floor", x, y, width, height, col);
                  ifloor2.AddComponent(boxCollider);
                  ifloor2.tag = "floor";
                  x += width;
                  break;
                case " ":
                  x += (width / 2);
                  break;
                case ">":
                  x += (width / 2);
                  break;
                case "<":
                  x -= (width / 2);
                  break;
                case "+":
                  y -= height;
                  break;
                case "-":
                  y += height;
                  break;
              }
            }
            break;
          case "r":
            var possibleChars = ["_", " ", ">", "<", "+", "-"];
            var randomChar = possibleChars[randomNumber(0, possibleChars.length - 1)];
            switch(randomChar)
            {
              case "_":
                var ifloor3 = Instantiate("floor", x, y, width, height, col);
                ifloor3.AddComponent(boxCollider);
                ifloor3.tag = "floor";
                x += width;
                break;
              case " ":
                x += (width / 2);
                break;
              case ">":
                x += (width / 2);
                break;
              case "<":
                x -= (width / 2);
                break;
              case "+":
                y -= height;
                break;
              case "-":
                y += height;
                break;
              }
            break;
        }
      }
    }
    
    //Engine Function
    {
      //Returns index of a gameObject
      function FindGameObjectIndex(go)
      {
        for(var i = 0; i < GameObjects.length; i++)
        {
          if(GameObjects[i].name == go.name)
          {
            return i;
          }
        }
      }
      
      //Creates a canvas and draws an object on it
      function DrawObject(go)
      {
        go.name = go.name + randomNumber(0, 100000);
        createCanvas(go.name);
        setActiveCanvas(go.name);
        setPosition(go.name,go.transform.position.x, go.transform.position.y);
        if(!go.spriteRenderer.outline)
        {
          setStrokeColor(go.spriteRenderer.color);
        }
        setFillColor(go.spriteRenderer.color);
        if(go.spriteRenderer.square)
        {
          rect(0, 0, go.transform.scale.width, go.transform.scale.height);
        }
        else
        {
            circle(go.transform.scale.width / 2, go.transform.scale.width / 2, go.transform.scale.width / 2);
        }
      }
    }
  }

  //Script Handling
  {
    //Input name of a function as a string to be able to add that function as a component of gameObjects 
    function CreateScript(info)
    {
      var newScript = {};
      newScript.name = info;
      newScript.objects = [];
      appendItem(Scripts, newScript);
    }
    
    //Input names of functions as a string array to be able to add them as a component of gameObjects 
    function CreateScripts(info)
    {
      for(var i = 0; i < info.length; i++)
      {
        var newScript = {};
        newScript.name = info[i];
        newScript.objects = [];
        appendItem(Scripts, newScript);
      }
    }
    
    //Engine Function
    {
      //Applies functions to gameobjects
      function CheckScripts()
      {
        for(var i = 0; i < Scripts.length; i++)
        {
          for(var j = 0; j < Scripts[i].objects.length; j++)
          {
            if(GameObjects[Scripts[i].objects[j]].active)
            {
              var str = "(" + Scripts[i].objects[j] + ")";
              eval(Scripts[i].name + str);
            }
          }
        }
      }
    }
  }
  
  //UI Handling
  {
    //Create text on screen. Must input text name, text to display, x and y position, and color
    function CreateText(name, text, x, y, color)
    {
      var element = name + randomNumber(0,100000);
      textLabel(element, text);
      setProperty(element, "x", x);
      setProperty(element, "y", y);
      setProperty(element, "text-color", color);
      return element;
    }
  }
  
  //Physics Handling
  {
    //Engine Functions
    {
      var ActiveColliders = []; //Colliders that are active in the game
      //Updates which colliders are on a active game object
      function UpdateActiveColliders()
      {
        ActiveColliders = [];
        for(var i = 0; i < GameObjects.length; i++)
        {
          var obj = GameObjects[i];
          if(obj.active)
          {
            if(obj.BoxCollider != null)
            {
              if(obj.BoxCollider.active)
              {
                appendItem(ActiveColliders, obj);  
              }
            }
          }
        }
      }
      
      //Checks collision between objects. One of the objects must have a RigidBody to work
      function ApplyCollisions()
      {
        for(var i = 0; i < ActiveColliders.length; i++)
        {
          var go = ActiveColliders[i];
         
            var col1 = go.BoxCollider;
            col1.collisions.up = false;
            col1.collisions.right = false;
            col1.collisions.down = false;
            col1.collisions.left = false;
            col1.collisions.count = 0;
            col1.collisions.info = [];
            for(var j = 0; j < ActiveColliders.length; j++)
            {
              var go2 = ActiveColliders[j];
              if(go.Rigidbody != null || go2.Rigidbody != null)
              {
                if(i != j)
                {
                  var col2 = go2.BoxCollider;
                  if (
                        col1.x <= col2.x + col2.width &&
                        col1.x + col1.width >= col2.x &&
                        col1.y <= col2.y + col2.height &&
                        col1.y + col1.height >= col2.y
                      ) 
                      {
                        col1.collisions.count+=1;
                        appendItem(col1.collisions.info, go2);
                        if((col2.y + (col2.height / 1.3)) <= col1.y)
                        {
                          col1.collisions.up = true;
                          col2.collisions.down = true;
                        }
                        else if((col1.y + (col1.height / 1.3)) <= col2.y)
                        {
                          col1.collisions.down = true;
                          col2.collisions.up = true;
                        }
                        else if((col2.x + (col2.width / 1.05)) <= col1.x)
                        {
                          col1.collisions.left = true;
                          col2.collisions.right = true;
                        }
                        else if((col1.x + (col1.width)) <= col2.x)
                        {
                          col1.collisions.right = true;
                          col2.collisions.left = true;
                        }
                      }
                }
              }
              
            }
          
        }
      }
      
      var Gravity = 0.04; //Speed to accelerate GameObjects down
      //Accelerates all GameObjects with RigidBodies down, unless they have rigidbody.useGravity set to false
      function ApplyGravity()
      {
        for(var i = 0; i < GameObjects.length; i++)
        {
          if(GameObjects[i].Rigidbody != null && GameObjects[i].active)
          {
            var gorb = GameObjects[i].Rigidbody;
            if(gorb.useGravity)
            {
              gorb.SetVelocity(gorb.velocity.x, gorb.velocity.y + Gravity);
            }
          }
        }
      }
      
      //Moves all objects the direction and magnitude of their velocity, unless they cannot move that direction
      function ApplyVelocities()
      {
        for(var i = 0; i < GameObjects.length; i++)
        {
          var go = GameObjects[i];
          if(go.Rigidbody != null && go.active)
          {
            if(go.BoxCollider != null)
            {
               if(go.BoxCollider.collisions.up && go.Rigidbody.velocity.y < 0)
            {
              go.Rigidbody.velocity.y = 0;
            }
            if(go.BoxCollider.collisions.right && go.Rigidbody.velocity.x > 0)
            {
              go.Rigidbody.velocity.x = 0;
            }
            if(go.BoxCollider.collisions.down && go.Rigidbody.velocity.y > 0)
            {
              go.Rigidbody.velocity.y = 0;
            }
            if(go.BoxCollider.collisions.left && go.Rigidbody.velocity.x < 0)
            {
              go.Rigidbody.velocity.x = 0;
            }
            }
           
            
            go.transform.position.x += go.Rigidbody.velocity.x;
            go.transform.position.y += go.Rigidbody.velocity.y;
          }
        }
      }
      
      //Moves all objects the object.transform.position.direction
      function ApplyMoves()
      {
        for(var i = 0; i < GameObjects.length; i++)
        {
          var go = GameObjects[i];
          if(go.transform.position.direction.x != 0)
          {
            go.transform.position.x += go.transform.position.direction.x;
          }
          if(go.transform.position.direction.y != 0)
          {
             go.transform.position.y += go.transform.position.direction.y;
          }
        }
      }
      
      //Sets each canvas to the location of their gameObject
      function ApplyPositions()
      {
        for(var i = 0; i < GameObjects.length; i++)
        {
          var go = GameObjects[i];
          if(go.active)
          {
            setPosition(go.name, go.transform.position.x, go.transform.position.y);
            var goCol = go.BoxCollider;
            if(goCol != null)
            {
              goCol.x = go.transform.position.x;
              goCol.y = go.transform.position.y;
              goCol.width = go.transform.scale.width;
              goCol.height = go.transform.scale.height;
            }
          }
          
        }
      }
    }
  }
  
  //Camera
  {
    var cameraOffset = {x: 160, y: 200}; //Constant used to center camera
    var camera = Instantiate("camera", cameraOffset.x,cameraOffset.y,0,0,"black", false, true); //Create a object to be used as a camera
    
    //Engine Function
    {
      //Moves all objects the opposite direction the camera is trying to move in order to seem like the camera is moving
      function ApplyCameraPosition()
      {
        for(var i = 0; i < GameObjects.length; i++)
        {
          var go = GameObjects[i];
          if(go != camera && !go.staticPosition)
          {
            go.transform.position.x -= camera.transform.position.x;
            go.transform.position.x += cameraOffset.x;
            go.transform.position.y -= camera.transform.position.y;
            go.transform.position.y += cameraOffset.y;
          }
        }
        for(var j = 0; j < StaticGameObjects.length; j++)
        {
          var sgo = StaticGameObjects[j];
          if(sgo != camera)
          {
            setPosition(sgo, getProperty(sgo, "x") - camera.transform.position.x +  cameraOffset.x, getProperty(sgo, "y") - camera.transform.position.y +  cameraOffset.y);
          }
        }
      }
    }
  }
  
  //Input Handling
  {
   
    
    var xInput = 0;
    var yInput = 0;
    
    //Used to ensure smooth use of WASD
    var heldDownW = false;
    var heldDownS = false;
    var wHeldFirst = true;
    var heldDownD = false;
    var heldDownA = false;
    var dHeldFirst = true;
    
    //Checks for inputs
    onEvent("screen1", "keyup", function (keys) {
      if(keys.key == "w")
      {
       heldDownW = false;
      }
      else if(keys.key == "s")
      {
       heldDownS = false;
      }
    });
    onEvent("screen1", "keydown", function (keys) {
      if(keys.key == "w")
      {
        if(!heldDownS)
        {
          wHeldFirst = true;
        }
        else{
          wHeldFirst = false;
        }
        heldDownW = true;
      }
      else if(keys.key == "s")
      {
        if(!heldDownW)
        {
          wHeldFirst = false;
        }
         else{
          wHeldFirst = true;
        }
        heldDownS = true;
      }
    });
    onEvent("screen1", "keyup", function (keys) {
      if(keys.key == "d")
      {
       heldDownD = false;
      }
      else if(keys.key == "a")
      {
       heldDownA = false;
      }
    });
    onEvent("screen1", "keydown", function (keys) {
      if(keys.key == "d")
      {
        if(!heldDownA)
        {
          dHeldFirst = true;
        }
        else{
          dHeldFirst = false;
        }
        heldDownD = true;
      }
      else if(keys.key == "a")
      {
        if(!heldDownD)
        {
          dHeldFirst = false;
        }
         else{
          dHeldFirst = true;
        }
        heldDownA = true;
      }
    });
    
    //Engine Function
    {
      //Determines values for horizontal and vertical input
      function DetermineInputValues()
      {
        xInput = 0;
         if(heldDownD)
        {
          xInput = 1;
        }
        if(heldDownA){
          xInput = -1;
        }
        if(heldDownD && heldDownA && dHeldFirst)
        {
          xInput = -1;
        }
        if(heldDownD && heldDownA && !dHeldFirst)
        {
          xInput = 1;
        }
        yInput = 0;
         if(heldDownW)
        {
          yInput = -1;
        }
        if(heldDownS){
          yInput = 1;
        }
        if(heldDownW && heldDownS && wHeldFirst)
        {
          yInput = 1;
        }
        if(heldDownW && heldDownS && !wHeldFirst)
        {
          yInput = -1;
        }
        
        horizontalInput = xInput;
        verticalInput = yInput;
      }
    }
    var KeyStates = {q: false, w: false, e: false,r: false,t: false,y: false,u: false,i: false,o: false,p: false,a: false,s: false,d: false,f: false,g: false,h: false,j: false,k: false,l: false,z: false,x: false,c: false,v: false,b: false,n: false,m: false, up: false, right: false, down: false, left: false};
    
    //Checks for inputs
    onEvent("screen1", "keydown", function (keys) {
      KeyStates.q = keys.key == "q";
      KeyStates.w = keys.key == "w";
      KeyStates.e = keys.key == "e";
      KeyStates.r = keys.key == "r";
      KeyStates.t = keys.key == "t";
      KeyStates.y = keys.key == "y";
      KeyStates.u = keys.key == "u";
      KeyStates.i = keys.key == "i";
      KeyStates.o = keys.key == "o";
      KeyStates.p = keys.key == "p";
      KeyStates.a = keys.key == "a";
      KeyStates.s = keys.key == "s";
      KeyStates.d = keys.key == "d";
      KeyStates.f = keys.key == "f";
      KeyStates.g = keys.key == "g";
      KeyStates.h = keys.key == "h";
      KeyStates.j = keys.key == "j";
      KeyStates.k = keys.key == "k";
      KeyStates.l = keys.key == "l";
      KeyStates.z = keys.key == "z";
      KeyStates.x = keys.key == "x";
      KeyStates.c = keys.key == "c";
      KeyStates.v = keys.key == "v";
      KeyStates.b = keys.key == "b";
      KeyStates.n = keys.key == "n";
      KeyStates.m = keys.key == "m";
      KeyStates.up = keys.key == "up";
      KeyStates.right = keys.key == "right";
      KeyStates.down = keys.key == "down";
      KeyStates.left = keys.key == "left";
    });
    onEvent("screen1", "keyup", function (keys) {
      KeyStates.q = !keys.key == "q";
      KeyStates.w = !keys.key == "w";
      KeyStates.e = !keys.key == "e";
      KeyStates.r = !keys.key == "r";
      KeyStates.t = !keys.key == "t";
      KeyStates.y = !keys.key == "y";
      KeyStates.u = !keys.key == "u";
      KeyStates.i = !keys.key == "i";
      KeyStates.o = !keys.key == "o";
      KeyStates.p = !keys.key == "p";
      KeyStates.a = !keys.key == "a";
      KeyStates.s = !keys.key == "s";
      KeyStates.d = !keys.key == "d";
      KeyStates.f = !keys.key == "f";
      KeyStates.g = !keys.key == "g";
      KeyStates.h = !keys.key == "h";
      KeyStates.j = !keys.key == "j";
      KeyStates.k = !keys.key == "k";
      KeyStates.l = !keys.key == "l";
      KeyStates.z = !keys.key == "z";
      KeyStates.x = !keys.key == "x";
      KeyStates.c = !keys.key == "c";
      KeyStates.v = !keys.key == "v";
      KeyStates.b = !keys.key == "b";
      KeyStates.n = !keys.key == "n";
      KeyStates.m = !keys.key == "m";
      KeyStates.up = !keys.key == "up";
      KeyStates.right = !keys.key == "right";
      KeyStates.down = !keys.key == "down";
      KeyStates.left = !keys.key == "left";
    });
  }

  //Optional Functions
  {
    var updateColors = true; //Whether or not to update colors every frame
    
    var turnOffNonVisible = true; //Turn off colliders when they are off screen, then turn them back on when they are on screen again
    var cameraTurnOffDistance = 250; //Distance from camera to turn off objects
    
    //Engine Functions
    {
      //Changes color of objects to their spriteRenderer.color every frame
      function UpdateColors()
      {
        for(var i = 0; i < GameObjects.length; i++)
        {
          var go = GameObjects[i];
          setActiveCanvas(go.name);
          clearCanvas(go.name);
          setPosition(go.name,go.transform.position.x, go.transform.position.y);
          if(!go.spriteRenderer.outline)
          {
            setStrokeColor(go.spriteRenderer.color);
          }
          setFillColor(go.spriteRenderer.color);
          if(go.spriteRenderer.square)
          {
            rect(0, 0, go.transform.scale.width, go.transform.scale.height);
          }
          else
          {
            circle(go.transform.scale.width / 2, go.transform.scale.width / 2, go.transform.scale.width / 2);
          }
        }
      }
      
      //Turns off objects that are a certain distance from camera
      function TurnOffNonVisible()
      {
        for(var i = 0; i < GameObjects.length; i++)
        {
          var go = GameObjects[i];
          if(go != camera&& go.BoxCollider != null)
          {
            if(DistanceBetween(go, camera) > cameraTurnOffDistance)
            {
              go.BoxCollider.active = false;  
            }
            else
            {
              go.BoxCollider.active = true;  
            }
          }
          UpdateActiveColliders();
        }
      }
    }
  }

  //Useful Functions
  {
    //Waits inputed time, then calls the function inputed. function inputed should be a string
    function Wait(timeout, functionName)
    {
      timeout *= 1000;
      var newLoop = timedLoop(timeout, function(){
          eval(functionName + "()");
          stopTimedLoop(newLoop);
      });
    }
    
    //Forever Waits inputed time, then calls the function inputed. function inputed should be a string
    function ForeverLoop(timeout, functionName)
    {
      timedLoop(timeout * 1000, function(){eval(functionName + "()");});
    }
    
    //Checks distance between center of two objects
    function DistanceBetween(go1, go2)
    {
      if(go1 != null && go2 != null)
      {
        var x1 = go1.transform.position.x + (go1.transform.scale.width / 2);
        var x2 = go2.transform.position.x + (go2.transform.scale.width / 2);
        var y1 = go1.transform.position.y + (go1.transform.scale.height / 2);
        var y2 = go2.transform.position.y + (go2.transform.scale.height / 2);
        
        var xdist = Math.abs(x1 - x2);
        var ydist = Math.abs(y1 - y2);
        var xsqr = xdist * xdist;
        var ysqr = ydist * ydist;
        
        var xdyd = xsqr + ysqr;
        
        var sqrtxy = Math.sqrt(xdyd);
        
        return sqrtxy;
      }
    }
    
    //Sets background color to inputed color
    function SetBackground(color)
    {
      setProperty("screen1", "background-color", color);
    }
    
    //Creates a simple player object
    function CreatePlayer()
    {
      var simplePlayer = Instantiate("simplePlayer", 50, 50, 50, 50, Color.blue);
      {
        CreateScript("SimplePlayerScript");
        simplePlayer.AddComponent(rigidBody);
        simplePlayer.AddComponent(boxCollider);
        simplePlayer.tag = "player";
        simplePlayer.AddComponent(script, "SimplePlayerScript");
        simplePlayer.variables.speed = 1.5;
        simplePlayer.variables.jump = 2.7;
        simplePlayer.variables.canJump = true;
        simplePlayer.variables.canResetJump = false;
        simplePlayer.variables.canShoot = true;
        simplePlayer.variables.reloading = false;
      }
    }
    //Used by CreatePlayer()
    function SimplePlayerScript(index)
    {
      var simplePlayer = GameObjects[index];
      var simplerb = simplePlayer.Rigidbody;
      simplerb.SetVelocity(horizontalInput * simplePlayer.variables.speed, simplerb.velocity.y);
       
      if(verticalInput < 0 &&  simplePlayer.variables.canJump && simplePlayer.BoxCollider.collisions.down)
      {
        simplerb.velocity.y = 0;
        simplerb.AddForce(0, simplePlayer.variables.jump);
        simplePlayer.variables.canJump = false;
        simplePlayer.variables.canResetJump = false;
      }
      if(!simplePlayer.BoxCollider.collisions.down)
      {
        simplePlayer.variables.canResetJump = true;
      }
    
      if(simplePlayer.BoxCollider.collisions.down && simplePlayer.variables.canResetJump)
      {
        simplePlayer.variables.canJump = true;
        simplePlayer.variables.canResetJump = false;
      }
      
      camera.transform.position.x = simplePlayer.transform.position.x;
    }
    
    //Creates a simple enemy object
    function CreateEnemy()
    {
       var enemy = Instantiate("enemy", 200, 50, 50, 50, Color.red);
      {
        CreateScript("SimpleEnemyScript");
        enemy.AddComponent(rigidBody);
        enemy.AddComponent(boxCollider);
        enemy.tag = "enemy";
        enemy.AddComponent(script, "SimpleEnemyScript");
        enemy.variables.right = false;
        enemy.variables.changeDir = false;
        enemy.variables.calledChange = false;
        enemy.variables.changeTime = 2;
        enemy.variables.speed = 0.3;
      }
    }
    
    //Used by CreateEnemy()
    function SimpleEnemyScript(index)
    {
      var simpleEnemy = GameObjects[index];
      var simpleerb = simpleEnemy.Rigidbody;
      if(simpleEnemy.variables.right)
      {
        simpleerb.SetVelocity(simpleEnemy.variables.speed, simpleerb.velocity.y);
      }
      else
      {
         simpleerb.SetVelocity(-simpleEnemy.variables.speed, simpleerb.velocity.y);
      }
      if(simpleEnemy.variables.changeDir)
      {
        simpleEnemy.variables.changeDir = false;
        simpleEnemy.variables.right = !simpleEnemy.variables.right;
      }
      else
      {
        if(!simpleEnemy.variables.calledChange)
        {
          simpleEnemy.variables.calledChange = true;
          var newLoop = timedLoop(simpleEnemy.variables.changeTime * 1000, function(){
          simpleEnemy.variables.changeDir = true;
          simpleEnemy.variables.calledChange = false;
          stopTimedLoop(newLoop);
          });
        }
      }
    }
  }
  
  //Starting Game Engine
  {
    Start();
    var fixedTime = 10; //How often draw function is called
    timedLoop(fixedTime, function(){draw();});
    var slowTime = 500; //How often slowDraw function is called
    timedLoop(slowTime, function(){slowDraw();});
  }
}
