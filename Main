var player;
var rb;
var floor;
var wall;
var speed = 1.5;
var canJump = true;
var canResetJump = false;

var canShoot = true;


//Called once before the first frame
function Start()
{
  //Call this function in the start function to open up a url to more info:
  // open("https://github.com/crocodile39/ObjectOrientedAppLab/blob/main/Main");

  wall = Instantiate("wall", 100, 320, 50, 50, Color.orange);
  wall.AddComponent(boxCollider);
  wall.tag = "wall";
  floor = Instantiate("floor", 0, 400, 320, 50, Color.green);
  floor.AddComponent(boxCollider);
  floor.tag = "floor";
  
  player = Instantiate("player", 50, 50, 50, 50, Color.indigo);
  player.AddComponent(rigidBody);
  rb = player.Rigidbody;
  player.AddComponent(boxCollider);
  player.tag = "player";
}

//Called every frame
function Update()
{
  rb.SetVelocity(horizontalInput * speed, rb.velocity.y);

  if(verticalInput < 0 && canJump && player.BoxCollider.collisions.down)
  {
    rb.velocity.y = 0;
    rb.AddForce(0, 2.7);
    canJump = false;
    canResetJump = false;
  }
  if(!player.BoxCollider.collisions.down)
  {
    canResetJump = true;
  }
  

  if(player.BoxCollider.collisions.down && canResetJump)
  {
    canJump = true;
    canResetJump = false;
  }
  
  if(canShoot && Input.getKey("e"))
  {
    canShoot = false;
    console.log("SHOOOOOOOOT");
    Wait(2, "Reload");
  }
  
  
  camera.transform.position.x = player.transform.position.x;
}

function Reload()
{
  canShoot = true;
}







//UNITY UNITY UNITY UNITY UNITY UNITY UNITY UNITY UNITY UNITY UNITY UNITY UNITY UNITY


function draw()
{
  DetermineInputValues();
  Update();
  ApplyCameraPosition();
  ApplyCollisions();
  ApplyGravity();
  ApplyVelocities();
  ApplyPositions();
}


//GAMEOBJECT HANDLING
var GameObjects = [];

var rigidBody = "rigidBody";
var boxCollider = "boxCollider";


function Instantiate(name, x, y, width, height, color)
{
  var ngo = {};
  ngo.name = name;
  ngo.tag = "default";
  ngo.active = true;
  ngo.transform = {};
  
  ngo.transform.position = {x: x, y: y};
  if(width > 320)
  {
    console.log("When instantiating, width cannot be greater than 320");
    width = 320;
  }
  if(height > 450)
  {
    console.log("When instantiating, heigh cannot be greater than 450");
    height = 450;
  }
  ngo.transform.scale = {width: width, height: height};
  ngo.spriteRenderer = {color: color};
  appendItem(GameObjects, ngo);
  DrawObject(ngo);
  
  ngo.SetActive =  function SetActive(on)
  {
    ngo.active = on;
    if(ngo.active)
    {
      setPosition(ngo.name, ngo.transform.position.x, ngo.transform.position.y);
    }
    else
    {
      setPosition(ngo.name, 1000, 1000);
    }
  };
  
  ngo.AddComponent = function AddComponent(component)
  {
    switch(component)
    {
      case rigidBody:
        if(ngo.Rigidbody != null)
        {
          console.log("You have already added a " + component + " to " + ngo.name + ". Do not add more than one");
        }
        else
        {
          ngo.Rigidbody = {};
          ngo.Rigidbody.velocity = {x: 0, y: 0};
          ngo.Rigidbody.useGravity = {gravity: true};
          ngo.Rigidbody.SetVelocity = function AddComponent(x, y)
          {
            if(x != null && y != null)
            {
              ngo.Rigidbody.velocity.x = x;
              ngo.Rigidbody.velocity.y = y;
            }
            else
            {
              console.log("When using Rigidbody.SetVelocity(), you must input a x and y value");
            }
          };
          ngo.Rigidbody.AddForce = function AddForce(x, y)
          {
                x /= 10;
                y /= 10;
                var currentVelocityX = x;
                var currentVelocityY = -y;
                var resistance = 0.01;
                var newLoop = timedLoop(fixedTime, function(){
                currentVelocityX -= resistance;
                currentVelocityY += resistance;
                if(currentVelocityX > 0)
                {
                  ngo.Rigidbody.velocity.x += currentVelocityX;
                }
                if(currentVelocityY < 0)
                {
                  ngo.Rigidbody.velocity.y += currentVelocityY;
                }
                if(currentVelocityX <= 0 && currentVelocityY >= 0)
                {
                  stopTimedLoop(newLoop);
                }
            });
          };
        }
        break;
      case boxCollider:
        if(ngo.BoxCollider != null)
        {
          console.log("You have already added a " + component + " to " + ngo.name + ". Do not add more than one");
        }
        else
        {
          ngo.BoxCollider = {x: ngo.transform.position.x, y: ngo.transform.position.y, width: ngo.transform.scale.width, height: ngo.transform.scale.height};
          ngo.BoxCollider.collisions = {up: false, right: false, down: false, left: false};
          ngo.BoxCollider.collisions.count = {};
          ngo.BoxCollider.collisions.info = [];
          ngo.BoxCollider.collisions.CompareTag = function CompareTag(tag)
          {
            for(var curcol = 0; curcol < ngo.BoxCollider.collisions.info.length; curcol++)
            {
              var hitObj = ngo.BoxCollider.collisions.info[curcol];
              if(hitObj.tag == tag)
              {
                return true;
              }
            }
          };
          ngo.BoxCollider.collisions.GetTag = function GetTag(tag)
          {
            for(var curcol = 0; curcol < ngo.BoxCollider.collisions.info.length; curcol++)
            {
              var hitObj = ngo.BoxCollider.collisions.info[curcol];
              if(hitObj.tag == tag)
              {
                return ngo.BoxCollider.collisions.info[curcol];
              }
            }
          };
        }
        break;
    }
  };
  
  
  return ngo;
}

function DrawObject(go)
{
  createCanvas(go.name);
  setActiveCanvas(go.name);
  setPosition(go.name,go.transform.position.x, go.transform.position.y);
  // setStrokeColor(go.spriteRenderer.color);
  setFillColor(go.spriteRenderer.color);
  rect(0, 0, go.transform.scale.width, go.transform.scale.height);
}


//PHYSICS HANDLING
function ApplyCollisions()
{
  for(var i = 0; i < GameObjects.length; i++)
  {
    var go = GameObjects[i];
    if(go.BoxCollider != null && go.active)
    {
      var col1 = go.BoxCollider;
      col1.collisions.up = false;
      col1.collisions.right = false;
      col1.collisions.down = false;
      col1.collisions.left = false;
      col1.collisions.count = 0;
      col1.collisions.info = [];
      for(var j = 0; j < GameObjects.length; j++)
      {
        var go2 = GameObjects[j];
        if(go2.BoxCollider != null && go2 != go && go2.active)
        {
         
          var col2 = go2.BoxCollider;
         
          if (
                col1.x <= col2.x + col2.width &&
                col1.x + col1.width >= col2.x &&
                col1.y <= col2.y + col2.height &&
                col1.y + col1.height >= col2.y
              ) 
              {
                col1.collisions.count+=1;
                appendItem(col1.collisions.info, go2);
                if((col2.y + (col2.height / 1.3)) <= col1.y)
                {
                  col1.collisions.up = true;
                }
                else if((col1.y + (col1.height / 1.3)) <= col2.y)
                {
                  col1.collisions.down = true;
                }
                else if((col2.x + (col2.width / 1.05)) <= col1.x)
                {
                  col1.collisions.left = true;
                }
                else if((col1.x + (col1.width)) <= col2.x)
                {
                  col1.collisions.right = true;
                }
              }
        }
      }
    }
  }
}

var Gravity = 0.04;
function ApplyGravity()
{
  for(var i = 0; i < GameObjects.length; i++)
  {
    if(GameObjects[i].Rigidbody != null && GameObjects[i].active)
    {
      var gorb = GameObjects[i].Rigidbody;
      if(gorb.useGravity)
      {
        gorb.SetVelocity(gorb.velocity.x, gorb.velocity.y + Gravity);
      }
    }
  }
}

function ApplyVelocities()
{
  for(var i = 0; i < GameObjects.length; i++)
  {
    var go = GameObjects[i];
    if(go.Rigidbody != null && go.active)
    {
      
      if(go.BoxCollider.collisions.up && go.Rigidbody.velocity.y < 0)
      {
        go.Rigidbody.velocity.y = 0;
      }
      if(go.BoxCollider.collisions.right && go.Rigidbody.velocity.x > 0)
      {
        go.Rigidbody.velocity.x = 0;
      }
      if(go.BoxCollider.collisions.down && go.Rigidbody.velocity.y > 0)
      {
        go.Rigidbody.velocity.y = 0;
      }
      if(go.BoxCollider.collisions.left && go.Rigidbody.velocity.x < 0)
      {
        go.Rigidbody.velocity.x = 0;
      }
      
      go.transform.position.x += go.Rigidbody.velocity.x;
      go.transform.position.y += go.Rigidbody.velocity.y;
    }
  }
}

function ApplyPositions()
{
  for(var i = 0; i < GameObjects.length; i++)
  {
    var go = GameObjects[i];
    if(go.active)
    {
      setPosition(go.name, go.transform.position.x, go.transform.position.y);
      var goCol = go.BoxCollider;
      if(goCol != null)
      {
        goCol.x = go.transform.position.x;
        goCol.y = go.transform.position.y;
        goCol.width = go.transform.scale.width;
        goCol.height = go.transform.scale.height;
      }
    }
    
  }
}

//CAMERA
var cameraOffset = {x: 160, y: 200};
var camera = Instantiate("camera", cameraOffset.x,cameraOffset.y,0,0,"black");

function ApplyCameraPosition()
{
  for(var i = 0; i < GameObjects.length; i++)
  {
    var go = GameObjects[i];
    if(go != camera)
    {
      go.transform.position.x -= camera.transform.position.x;
      go.transform.position.x += cameraOffset.x;
      go.transform.position.y -= camera.transform.position.y;
      go.transform.position.y += cameraOffset.y;
    }
    
  }
}



//INPUT HANDLING

var horizontalInput = 0;
var verticalInput = 0;

var xInput = 0;
var yInput = 0;

//Engine variables, not for use.
var heldDownW = false;
var heldDownS = false;
var wHeldFirst = true;
var heldDownD = false;
var heldDownA = false;
var dHeldFirst = true;

onEvent("screen1", "keyup", function (keys) {
  if(keys.key == "w")
  {
   heldDownW = false;
  }
  else if(keys.key == "s")
  {
   heldDownS = false;
  }
});
onEvent("screen1", "keydown", function (keys) {
  if(keys.key == "w")
  {
    if(!heldDownS)
    {
      wHeldFirst = true;
    }
    else{
      wHeldFirst = false;
    }
    heldDownW = true;
  }
  else if(keys.key == "s")
  {
    if(!heldDownW)
    {
      wHeldFirst = false;
    }
     else{
      wHeldFirst = true;
    }
    heldDownS = true;
  }
});
onEvent("screen1", "keyup", function (keys) {
  if(keys.key == "d")
  {
   heldDownD = false;
  }
  else if(keys.key == "a")
  {
   heldDownA = false;
  }
});
onEvent("screen1", "keydown", function (keys) {
  if(keys.key == "d")
  {
    if(!heldDownA)
    {
      dHeldFirst = true;
    }
    else{
      dHeldFirst = false;
    }
    heldDownD = true;
  }
  else if(keys.key == "a")
  {
    if(!heldDownD)
    {
      dHeldFirst = false;
    }
     else{
      dHeldFirst = true;
    }
    heldDownA = true;
  }
});

//Engine Function, not for use.
function DetermineInputValues()
{
  xInput = 0;
   if(heldDownD)
  {
    xInput = 1;
  }
  if(heldDownA){
    xInput = -1;
  }
  if(heldDownD && heldDownA && dHeldFirst)
  {
    xInput = -1;
  }
  if(heldDownD && heldDownA && !dHeldFirst)
  {
    xInput = 1;
  }
  yInput = 0;
   if(heldDownW)
  {
    yInput = -1;
  }
  if(heldDownS){
    yInput = 1;
  }
  if(heldDownW && heldDownS && wHeldFirst)
  {
    yInput = 1;
  }
  if(heldDownW && heldDownS && !wHeldFirst)
  {
    yInput = -1;
  }
  
  horizontalInput = xInput;
  verticalInput = yInput;
}

var Input = {};
Input.getKey = function getKey(key)
{
  switch(key)
  {
    case "q":
      return KeyStates.q;
    case "w":
      return KeyStates.w;
    case "e":
      return KeyStates.e;
    case "r":
      return KeyStates.r;
    case "t":
      return KeyStates.t;
    case "y":
      return KeyStates.y;
    case "u":
      return KeyStates.u;
    case "i":
      return KeyStates.i;
    case "o":
      return KeyStates.o;
    case "p":
      return KeyStates.p;
    case "a":
      return KeyStates.a;
    case "s":
      return KeyStates.s;
    case "d":
      return KeyStates.d;
    case "f":
      return KeyStates.f;
    case "g":
      return KeyStates.g;
    case "h":
      return KeyStates.h;
    case "j":
      return KeyStates.j;
    case "k":
      return KeyStates.k;
    case "l":
      return KeyStates.l;
    case "z":
      return KeyStates.z;
    case "x":
      return KeyStates.x;
    case "c":
      return KeyStates.c;
    case "v":
      return KeyStates.v;
    case "b":
      return KeyStates.b;
    case "n":
      return KeyStates.n;
    case "m":
      return KeyStates.m;
    case "up":
      return KeyStates.up;
    case "right":
      return KeyStates.right;
    case "down":
      return KeyStates.down;
    case "left":
      return KeyStates.left;
    
  }
};

var KeyStates = {q: false, w: false, e: false,r: false,t: false,y: false,u: false,i: false,o: false,p: false,a: false,s: false,d: false,f: false,g: false,h: false,j: false,k: false,l: false,z: false,x: false,c: false,v: false,b: false,n: false,m: false, up: false, right: false, down: false, left: false};


onEvent("screen1", "keydown", function (keys) {
  KeyStates.q = keys.key == "q";
  KeyStates.w = keys.key == "w";
  KeyStates.e = keys.key == "e";
  KeyStates.r = keys.key == "r";
  KeyStates.t = keys.key == "t";
  KeyStates.y = keys.key == "y";
  KeyStates.u = keys.key == "u";
  KeyStates.i = keys.key == "i";
  KeyStates.o = keys.key == "o";
  KeyStates.p = keys.key == "p";
  KeyStates.a = keys.key == "a";
  KeyStates.s = keys.key == "s";
  KeyStates.d = keys.key == "d";
  KeyStates.f = keys.key == "f";
  KeyStates.g = keys.key == "g";
  KeyStates.h = keys.key == "h";
  KeyStates.j = keys.key == "j";
  KeyStates.k = keys.key == "k";
  KeyStates.l = keys.key == "l";
  KeyStates.z = keys.key == "z";
  KeyStates.x = keys.key == "x";
  KeyStates.c = keys.key == "c";
  KeyStates.v = keys.key == "v";
  KeyStates.b = keys.key == "b";
  KeyStates.n = keys.key == "n";
  KeyStates.m = keys.key == "m";
  KeyStates.up = keys.key == "up";
  KeyStates.right = keys.key == "right";
  KeyStates.down = keys.key == "down";
  KeyStates.left = keys.key == "left";
});

onEvent("screen1", "keyup", function (keys) {
  KeyStates.q = !keys.key == "q";
  KeyStates.w = !keys.key == "w";
  KeyStates.e = !keys.key == "e";
  KeyStates.r = !keys.key == "r";
  KeyStates.t = !keys.key == "t";
  KeyStates.y = !keys.key == "y";
  KeyStates.u = !keys.key == "u";
  KeyStates.i = !keys.key == "i";
  KeyStates.o = !keys.key == "o";
  KeyStates.p = !keys.key == "p";
  KeyStates.a = !keys.key == "a";
  KeyStates.s = !keys.key == "s";
  KeyStates.d = !keys.key == "d";
  KeyStates.f = !keys.key == "f";
  KeyStates.g = !keys.key == "g";
  KeyStates.h = !keys.key == "h";
  KeyStates.j = !keys.key == "j";
  KeyStates.k = !keys.key == "k";
  KeyStates.l = !keys.key == "l";
  KeyStates.z = !keys.key == "z";
  KeyStates.x = !keys.key == "x";
  KeyStates.c = !keys.key == "c";
  KeyStates.v = !keys.key == "v";
  KeyStates.b = !keys.key == "b";
  KeyStates.n = !keys.key == "n";
  KeyStates.m = !keys.key == "m";
  KeyStates.up = !keys.key == "up";
  KeyStates.right = !keys.key == "right";
  KeyStates.down = !keys.key == "down";
  KeyStates.left = !keys.key == "left";
});


var Color = {black : "black", white: "white", grey: "gray", gray: "gray", red: "red", orange: "orange", yellow: "yellow", green: "green", blue: "blue", indigo: "indigo", violet: "violet"};

//Useful Functions
function Wait(timeout, functionName)
{
  timeout *= 1000;
  var newLoop = timedLoop(timeout, function(){
      eval(functionName + "()");
      stopTimedLoop(newLoop);
  });
}

function ForeverLoop(timeout, functionName)
{
  timedLoop(timeout * 1000, function(){eval(functionName + "()");});
}
//Useful Functions

Start();
var fixedTime = 1;
timedLoop(fixedTime, function(){draw();});
